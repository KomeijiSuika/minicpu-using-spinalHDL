00100493 // PC=0x0 line=3: addi s1, x0, 1
01c49493 // PC=0x4 line=4: slli s1, s1, 28 # s1 = 32'h1000_0000, the MMR Address
00806293 // PC=0x8 line=9: ori  t0, x0, 8 # led0
00429293 // PC=0xc line=10: slli t0, t0, 4
0042e293 // PC=0x10 line=11: ori  t0, t0, 4 # led1
00429293 // PC=0x14 line=12: slli t0, t0, 4
07f2e293 // PC=0x18 line=13: ori  t0, t0, 127 # half red
00829293 // PC=0x1c line=14: slli t0, t0, 8
0002e293 // PC=0x20 line=15: ori  t0, t0, 0 # no green
00829293 // PC=0x24 line=16: slli t0, t0, 8
0ff2e293 // PC=0x28 line=17: ori  t0, t0, 255 # full blue
0054a023 // PC=0x2c line=18: sw t0, 0(s1)
080000ef // PC=0x30 line=21: call VRAM_SWEEP # equivalent to JAL ra, VRAM_SWEEP
00c00493 // PC=0x34 line=28: addi s1, zero, 12
02048663 // PC=0x38 line=29: BLINK_FOR:  beq s1, zero, DONE
fff48493 // PC=0x3c line=30: addi s1, s1, -1
00100513 // PC=0x40 line=32: addi a0, zero, 1
044000ef // PC=0x44 line=33: jal ra, SET_LED0
0fa00513 // PC=0x48 line=35: addi a0, zero, 250
01c000ef // PC=0x4c line=36: jal ra, DELAY
00000533 // PC=0x50 line=38: add a0, zero, zero
034000ef // PC=0x54 line=39: jal ra, SET_LED0
1f400513 // PC=0x58 line=41: addi a0, zero, 500
00c000ef // PC=0x5c line=42: jal ra, DELAY
fd9ff06f // PC=0x60 line=43: j BLINK_FOR
00000063 // PC=0x64 line=45: DONE: beq x0, x0, DONE # infinite loop at end
00100293 // PC=0x68 line=48: DELAY: addi t0, x0, 1
01c29293 // PC=0x6c line=49: slli t0, t0, 28 # Get MMR base address into register t0.
00c2a303 // PC=0x70 line=51: lw t1, 12(t0)
00a303b3 // PC=0x74 line=53: add t2, t1, a0
00c2a303 // PC=0x78 line=54: DELAY_FOR:  lw t1, 12(t0)
00735463 // PC=0x7c line=55: bge t1, t2, DELAY_DONE
ff9ff06f // PC=0x80 line=56: j DELAY_FOR
00008067 // PC=0x84 line=57: DELAY_DONE: ret # shorthand for `jr ra`
00100293 // PC=0x88 line=60: SET_LED0:  addi t0, x0, 1 # Get MMR base address into register t0.
01c29293 // PC=0x8c line=61: slli t0, t0, 28
0002a303 // PC=0x90 line=63: lw t1, 0(t0)
000003b3 // PC=0x94 line=65: add t2, zero, zero
00050463 // PC=0x98 line=66: beq a0, zero, LED0_OFF # if LED 0 is off, skip next instruction.
00f00393 // PC=0x9c line=68: addi t2, zero, 15 # else case
01c39393 // PC=0xa0 line=69: LED0_OFF: slli t2, t2, 28
00734333 // PC=0xa4 line=71: xor t1, t1, t2
0062a023 // PC=0xa8 line=73: sw t1, 0(t0)
00008067 // PC=0xac line=74: ret # shorthand for `jr ra`
00200e13 // PC=0xb0 line=83: VRAM_SWEEP: addi t3, x0, 2
01ce1e13 // PC=0xb4 line=84: slli t3, t3, 28 # t3 =  32'h2000_0000, the base address for VRAM
04b00313 // PC=0xb8 line=85: addi t1, x0, 75 # t1 = x6 = 75
00a31313 // PC=0xbc line=86: slli t1, t1, 10 # # t1 = 320*240
00000293 // PC=0xc0 line=87: addi t0, x0, 0  # t0 : 'color' to write into the pixel
005e03b3 // PC=0xc4 line=88: LOOP_START: add t2, t3, t0 # t2 = x7 = x8 + x5
01128293 // PC=0xc8 line=89: addi t0, t0, 17
0053a023 // PC=0xcc line=90: sw t0, 0(t2)
fe62cae3 // PC=0xd0 line=91: blt t0, t1, LOOP_START
00008067 // PC=0xd4 line=92: ret
